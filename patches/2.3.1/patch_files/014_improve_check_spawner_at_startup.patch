diff -Naurx .git -x node_modules -x share -x __pycache__ ../jupyterhub/jupyterhub/app.py ../jupyterhub-patched/jupyterhub/app.py
--- ../jupyterhub/jupyterhub/app.py	2022-09-01 12:32:28.000000000 +0200
+++ ../jupyterhub-patched/jupyterhub/app.py	2022-09-01 12:33:06.000000000 +0200
@@ -2555,11 +2555,12 @@
                         spawner.server.port = 443
                     self.db.commit()
 
+                retries = [1,1,1,2,5,10,30,30]
                 self.log.debug(
                     "Verifying that %s is running at %s", spawner._log_name, url
                 )
                 try:
-                    await user._wait_up(spawner)
+                    await user._wait_up(spawner, retries)
                 except AnyTimeoutError:
                     self.log.error(
                         "%s does not appear to be running at %s, shutting it down.",
diff -Naurx .git -x node_modules -x share -x __pycache__ ../jupyterhub/jupyterhub/user.py ../jupyterhub-patched/jupyterhub/user.py
--- ../jupyterhub/jupyterhub/user.py	2022-09-01 12:32:30.000000000 +0200
+++ ../jupyterhub-patched/jupyterhub/user.py	2022-09-01 12:27:02.000000000 +0200
@@ -856,7 +856,7 @@
         spawner._waiting_for_response = True
         await self._wait_up(spawner)
 
-    async def _wait_up(self, spawner):
+    async def _wait_up(self, spawner, retries=[]):
         """Wait for a server to finish starting.
 
         Shuts the server down if it doesn't respond within
@@ -867,56 +867,65 @@
         cert = self.settings.get('internal_ssl_cert')
         ca = self.settings.get('internal_ssl_ca')
         ssl_context = make_ssl_context(key, cert, cafile=ca)
-        try:
-            resp = await server.wait_up(
-                http=True, timeout=spawner.http_timeout, ssl_context=ssl_context
-            )
-        except Exception as e:
-            if isinstance(e, AnyTimeoutError):
-                self.log.warning(
-                    f"{self.name}'s server never showed up at {server.url}"
-                    f" after {spawner.http_timeout} seconds. Giving up."
-                    f"\n{http_timeout_message}",
-                    extra={"action": "stoporigin"}
-                )
-                e.reason = 'timeout'
-                self.settings['statsd'].incr('spawner.failure.http_timeout')
-            else:
-                e.reason = 'error'
-                self.log.exception(
-                    "Unhandled error waiting for {user}'s server to show up at {url}: {error}".format(
-                        user=self.name, url=server.url, error=e
-                    ),
-                    extra={"action": "stoporigin"}
-                )
-                self.settings['statsd'].incr('spawner.failure.http_error')
-            # store state again for spawner.events
-            spawner.orm_spawner.state = spawner.get_state()
-            self.db.commit()
+        for i in range(0, len(retries)+1):
             try:
-                await self.stop(spawner.name)
-            except Exception:
-                self.log.exception(
-                    "Failed to cleanup {user}'s server that failed to start".format(
-                        user=self.name
-                    ),
-                    exc_info=True,
+                resp = await server.wait_up(
+                    http=True, timeout=spawner.http_timeout, ssl_context=ssl_context
                 )
-            # raise original TimeoutError
-            raise e
-        else:
-            server_version = resp.headers.get('X-JupyterHub-Version')
-            _check_version(__version__, server_version, self.log)
-            # record the Spawner version for better error messages
-            # if it doesn't work
-            spawner._jupyterhub_version = server_version
-        finally:
-            spawner._waiting_for_response = False
-            spawner._start_pending = False
-            # store state again for spawner.events
-            spawner.orm_spawner.state = spawner.get_state()
-            self.db.commit()
-        return spawner
+            except Exception as e:
+                if i < len(retries):
+                    import time
+                    self.log.info(
+                        f"{self.name}'s server not reachable at {server.url}."
+                        f" Try again in {retries[i]} seconds."
+                    )
+                    time.sleep(retries[i])
+                    continue
+                if isinstance(e, AnyTimeoutError):
+                    self.log.warning(
+                        f"{self.name}'s server never showed up at {server.url}"
+                        f" after {spawner.http_timeout} seconds. Giving up."
+                        f"\n{http_timeout_message}",
+                        extra={"action": "stoporigin"}
+                    )
+                    e.reason = 'timeout'
+                    self.settings['statsd'].incr('spawner.failure.http_timeout')
+                else:
+                    e.reason = 'error'
+                    self.log.error(
+                        "Unhandled error waiting for {user}'s server to show up at {url}: {error}".format(
+                            user=self.name, url=server.url, error=e
+                        ),
+                        extra={"action": "stoporigin"}
+                    )
+                    self.settings['statsd'].incr('spawner.failure.http_error')
+                # store state again for spawner.events
+                spawner.orm_spawner.state = spawner.get_state()
+                self.db.commit()
+                try:
+                    await self.stop(spawner.name)
+                except Exception:
+                    self.log.error(
+                        "Failed to cleanup {user}'s server that failed to start".format(
+                            user=self.name
+                        ),
+                        exc_info=True,
+                    )
+                # raise original TimeoutError
+                raise e
+            else:
+                server_version = resp.headers.get('X-JupyterHub-Version')
+                _check_version(__version__, server_version, self.log)
+                # record the Spawner version for better error messages
+                # if it doesn't work
+                spawner._jupyterhub_version = server_version
+            finally:
+                spawner._waiting_for_response = False
+                spawner._start_pending = False
+                # store state again for spawner.events
+                spawner.orm_spawner.state = spawner.get_state()
+                self.db.commit()
+            return spawner
 
     async def stop(self, server_name=''):
         """Stop the user's spawner
