diff -Naurx .git -x node_modules -x share -x __pycache__ ../jupyterhub/jupyterhub/app.py ../jupyterhub-patched/jupyterhub/app.py
--- ../jupyterhub/jupyterhub/app.py	2022-02-08 20:03:24.730996125 +0100
+++ ../jupyterhub-patched/jupyterhub/app.py	2022-02-08 20:05:14.618297051 +0100
@@ -5,6 +5,7 @@
 import asyncio
 import atexit
 import binascii
+import json
 import logging
 import os
 import re
@@ -136,6 +137,8 @@
 token_aliases.update(common_aliases)
 aliases.update(common_aliases)
 
+custom_config_timeout = os.environ.get("CUSTOM_CONFIG_CACHE_TIME", 60)
+
 flags = {}
 if isinstance(Application.flags, dict):
     flags.update(Application.flags)
@@ -254,6 +257,24 @@
         self.log = hub.log
         dbutil.upgrade_if_needed(hub.db_url, log=self.log)
 
+class TimedCacheProperty(object):
+    '''decorator to create get only property; values are fetched once per `timeout`'''
+    def __init__(self, timeout):
+        self._timeout = timedelta(seconds=timeout)
+        self._func = None
+        self._values = {}
+
+    def __get__(self, instance, cls):
+        last_lookup, value = self._values.get(instance, (datetime.min, None))
+        now = datetime.now()
+        if self._timeout < now - last_lookup:
+            value = self._func(instance)
+            self._values[instance] = now, value
+        return value
+
+    def __call__(self, func):
+        self._func = func
+        return self
 
 class JupyterHub(Application):
     """An Application for starting a Multi-User Jupyter Notebook server."""
@@ -357,6 +378,21 @@
         config=True
     )
 
+    custom_config_file = Unicode('jupyterhub_custom_config.json', help="The custom config file to load").tag(
+        config=True
+    )
+        
+    @TimedCacheProperty(timeout=custom_config_timeout)
+    def custom_config(self):
+        self.log.debug("Load custom config file.")
+        try:
+            with open(self.custom_config_file, "r") as f:
+                ret = json.load(f)
+        except:
+            self.log.warning("Could not load custom config file.", exc_info=True)
+            ret = {}
+        return ret
+
     @validate("config_file")
     def _validate_config_file(self, proposal):
         if not self.generate_config and not os.path.isfile(proposal.value):
